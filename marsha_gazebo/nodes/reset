#!/usr/bin/env python

# reset

# Resets the position of the pickup object

# Author: Aaron Borger

# TODO: Fix the domain randomization, its annoying needing to give value to reset

import rospy
import numpy as np

from gazebo_msgs.srv import DeleteModel
from gazebo_msgs.srv import SpawnModel
from gazebo_msgs.srv import SetLinkProperties
from gazebo_msgs.srv import SetModelState
from gazebo_msgs.srv import ApplyBodyWrench

from gazebo_msgs.msg import ModelState

from geometry_msgs.msg import Twist
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Point
from geometry_msgs.msg import Wrench
from geometry_msgs.msg import Vector3

from std_msgs.msg import Duration

from marsha_msgs.srv import Reset

from marsha_gazebo.auto_domain_randomization import DRandomizer

from std_msgs.msg import Empty
import sys

import random

import time

from std_srvs.srv import Trigger, TriggerResponse
MODEL_NAME = "pickup_object"

START_DIST = 0.2

WORK_SPACE_DIM = 0.3
DESIRED_VEL = 0.0254 # m/s = 1 in/sec
VEL_STDV = 0.005

ROBOT_POS = [0.085, 0.085, 0.079]


# Not using any more, but dont want to delete just incase
#delete_model = rospy.ServiceProxy('/gazebo/delete_model', DeleteModel)
#spawn_model = rospy.ServiceProxy('/gazebo/spawn_urdf_model', SpawnModel)

rospy.wait_for_service('/gazebo/set_model_state')
set_model = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)

rospy.wait_for_service('/gazebo/apply_body_wrench')
apply_wrench = rospy.ServiceProxy('/gazebo/apply_body_wrench', ApplyBodyWrench)

rospy.wait_for_service('/gazebo/set_link_properties')
set_link_properties = rospy.ServiceProxy('/gazebo/set_link_properties', SetLinkProperties)

rospy.wait_for_service('/gazebo/apply_body_wrench')
apply_body_wrench = rospy.ServiceProxy('/gazebo/apply_body_wrench', ApplyBodyWrench)

randomizer = DRandomizer((2), (-0.25, 0.25))

ar3_pickup = Pose()
ar3_pickup.position.x = -0.3
ar3_pickup.position.y = -0.1
ar3_pickup.position.z = 0.1

# left pickup 1

l_pickup_1 = Pose()
l_pickup_1.position.x = -0.13
l_pickup_1.position.y = -0.03
l_pickup_1.position.z = 0.1025


# left pickup 2
l_pickup_2 = Pose()
l_pickup_2.position.x = -0.08
l_pickup_2.position.y = -0.01
l_pickup_2.position.z = 0.1025



l_pickup_3 = Pose()
l_pickup_3.position.x = 0.13
l_pickup_3.position.y = -0.03
l_pickup_3.position.z = 0.1025

l_pickup_4 = Pose()
l_pickup_4.position.x = 0.08
l_pickup_4.position.y = -0.01
l_pickup_4.position.z = 0.1025


other_fold = Pose()
other_fold.position.x = -0.025
other_fold.position.y = -0.205
other_fold.position.z = 0.125



gravity = True
# If change works well, reset and all its requirements can be deleted
def reset(req):
    print("Resetting...")
    #domain, dar = randomizer.get_domain(req.reward)


    twist = Twist()

    success = set_link_properties(link_name="ball_1::pickup_object", gravity_mode=gravity)
    success = set_link_properties(link_name="ball_2::pickup_object", gravity_mode=gravity)
    success = set_link_properties(link_name="ball_3::pickup_object", gravity_mode=gravity)
    success = set_link_properties(link_name="ball_4::pickup_object", gravity_mode=gravity)
    #print("gravity success: ", success)
    desired_state = ModelState('ball_1', l_pickup_1, twist, 'world')

    # should redo with a better response (i did this at 3 am) and a for loop
    resp = set_model(desired_state)

    desired_state = ModelState('ball_2', l_pickup_2, twist, 'world')

    resp = set_model(desired_state)

    desired_state = ModelState('ball_3', l_pickup_3, twist, 'world')

    resp = set_model(desired_state)

    desired_state = ModelState('ball_4', l_pickup_4, twist, 'world')

    resp = set_model(desired_state)
    #print('dar:', dar, type(dar))
    return(resp.success)


class l_dir:
    def __init__(self, x=None, y=None, z=None):
        self.pos = [x, y, z]

        # definitely a better way to do this
        if (self.pos[0] == START_DIST):
            self.force_dir = [-1, 0, 0]
        elif (self.pos[0] == -START_DIST):
            self.force_dir = [1, 0, 0]
        elif (self.pos[1] == START_DIST):
            self.force_dir = [0, -1, 0]
        elif (self.pos[1] == -START_DIST):
            self.force_dir = [0, 1, 0]
        else:
            self.force_dir = [0, 0, 1]

    
    def get_pose(self):
        rand1 = np.random.uniform(low=-WORK_SPACE_DIM/2, high=WORK_SPACE_DIM/2) # rand1 isnt really used because it is in the x-direction which is the direction of motion
        rand2 = np.random.uniform(low=0, high=WORK_SPACE_DIM)
        rand3 = np.random.uniform(low=-WORK_SPACE_DIM/2, high=WORK_SPACE_DIM/2)


        rand = np.append(rand1, rand2)
        rand = np.append(rand, rand3)
        print("rand:", rand)

        pose = Pose()
        pos_arr = [0, 0, 0]
        for axis, pos in enumerate(self.pos):
            if (pos != None): # ball moves in this direction and position is already set
                pos_arr[axis] = pos
            else: # axis == None
                pos_arr[axis] = ROBOT_POS[axis] + rand[axis]

        pose.position.x = pos_arr[0]
        pose.position.y = pos_arr[1]
        pose.position.z = pos_arr[2]
        return pose

    def get_randomized_force(self):
        rand_vel = np.random.normal(DESIRED_VEL, VEL_STDV)

        # F = m*(v/t) = 0.011*(v/0.01)
        motion_force = 0.011*(rand_vel/0.01)
        rand = np.random.normal(0, 0.011*(VEL_STDV/0.01), size=(3,)) #randomness: 0.005 
        force = Vector3()
        force_arr = [0, 0, 0]
        for axis, force_val in enumerate(self.force_dir):
            if force_val == 0:
                force_arr[axis] = rand[axis]
            else:
                force_arr[axis] = motion_force

        force.x = force_arr[0]
        force.y = force_arr[1]
        force.z = force_arr[2]
        return force
            

    def get_force(self):
        return self.force

ar3_grav_launches = [l_dir(x=3)]


ar3_launches = [l_dir(x=1), l_dir(x=-1), l_dir(y=1), l_dir(y=-1)]

#arm2d2_launches = [l_dir(x=0.22, y=1, z=0.125)] #[l_dir(x=1, y=0.22, z=0.125), l_dir(x=-1, y=0.22, z=0.125), l_dir(x=-0.22, y=1, z=0.125), l_dir(x=-0.22, y=-1, z=0.125)]

arm2d2_launches = [l_dir(x=-1*START_DIST)] #l_dir(x=START_DIST, y=0.3)] #, ] #, l_dir(x=1, y=0.45)]

def launcher(data):
    launches = arm2d2_launches
    l = random.choice(launches)
    pose = l.get_pose()
    twist = Twist()

    success = set_link_properties(link_name="pickup_object::pickup_object", gravity_mode=gravity)
    print("gravity success: ", success)
    desired_state = ModelState('pickup_object', pose, twist, 'world')

    resp = set_model(desired_state)
    print('change success:', resp.success)

    # Add velocity
    ref_point = Point(0, 0, 0)
    wrench = Wrench()
    #wrench.force = Vector3(0.5, 0, 9)
    wrench.force = l.get_randomized_force()
    print("wrench: ", wrench.force)
    
    # Testing in grav, move later
    #force = Vector3(-2, 0, 9)
    #wrench.force = force


    duration = rospy.Duration(0.01)

    resp = apply_wrench(
        body_name="pickup_object::pickup_object",
        reference_point=ref_point,
        wrench=wrench,
        duration=duration

    )


    






def reset_server():
    rospy.init_node('reset_server')
    reset(None)
    s = rospy.Subscriber("reset", Empty, reset)
    rospy.spin()

def launch_server():
    rospy.init_node('reset_server')
    launcher(None)
    s = rospy.Subscriber("reset", Empty, launcher)
    rospy.spin()

if __name__ == "__main__":
    for i in range(1, len(sys.argv)):
        if sys.argv[i] == "launch":
            launch_server()
        if sys.argv[i] == "no_grav":
            gravity = False

    reset_server()