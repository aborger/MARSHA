#!/usr/bin/env python3

import rospy
import cv2


from marsha_detection.realsense_camera import *

from std_msgs.msg import UInt8MultiArray
from std_msgs.msg import MultiArrayLayout
from std_msgs.msg import MultiArrayDimension
from std_msgs.msg import UInt8
from std_msgs.msg import UInt32
from geometry_msgs.msg import Point


from marsha_msgs.srv import GetFrame
from marsha_msgs.srv import GetDepth


SIZE_REDUCTION = 4
IMAGE_HEIGHT = int(720 / SIZE_REDUCTION) # original: 720
IMAGE_WIDTH = int(1280 / SIZE_REDUCTION) # original: 1280
CHANNELS = 3

CONV_SIZE = 5 # Note it will be double this value

def conv_get_depth(frame, x, y):
    depth_list = []
    for col in range(x - CONV_SIZE, x + CONV_SIZE):
        for row in range(y - CONV_SIZE, y + CONV_SIZE):
            depth = frame.get_distance(y, x)
            depth_list.append(depth)

    avg = sum(depth_list) / len(depth_list)
    return avg

class CamServer():
    def __init__(self):
        self.rs = RealsenseCamera()
        self.get_frame_service = rospy.Service('get_rgb_frame', GetFrame, self.handleFrame)
        self.get_depth_service = rospy.Service('get_depth', GetDepth, self.handleDepth)

        self.frame_buffer = None
        self.depth_buffer = [] # Current frame = depth_buffer[10]
        self.frame_num = 0

        self.curr_pos = None
        self.curr_pos_frameID = 0

        self.mal = MultiArrayLayout()
        self.mal.dim.append(MultiArrayDimension())
        self.mal.dim[0].label = "height"
        self.mal.dim[0].size = IMAGE_HEIGHT
        self.mal.dim[0].stride = CHANNELS*IMAGE_WIDTH*IMAGE_HEIGHT
        self.mal.dim.append(MultiArrayDimension())
        self.mal.dim[1].label = "width"
        self.mal.dim[1].size = IMAGE_WIDTH
        self.mal.dim[1].stride = CHANNELS*IMAGE_WIDTH
        self.mal.dim.append(MultiArrayDimension())
        self.mal.dim[2].label = "channel"
        self.mal.dim[2].size = CHANNELS
        self.mal.dim[2].stride = CHANNELS
        self.mal.data_offset = 0

    def handleFrame(self, req):
        
        frame = cv2.resize(self.frame_buffer, (IMAGE_WIDTH, IMAGE_HEIGHT))
        pixel_list = np.reshape(frame, (CHANNELS*IMAGE_WIDTH*IMAGE_HEIGHT)).tolist()

        frame = UInt8MultiArray()
        frame.layout = self.mal
        frame.data = pixel_list

        return UInt8(self.frame_num), frame
        

    def handleDepth(self, req):
        frame_difference = self.frame_num - req.frame_id.data
        buffer_num = 10 - frame_difference

        try:
            depth_frame = self.depth_buffer[buffer_num]

        except IndexError:
            rospy.logerr("Detection System Delayed Too Much!")
            return Point(0, 0, 0)

        x_pix = int(req.x_pixel.data * SIZE_REDUCTION)
        y_pix = int(req.y_pixel.data * SIZE_REDUCTION)
        self.curr_pos = (x_pix, y_pix)
        self.curr_pos_frameID = req.frame_id.data
        point = self.rs.pixel_to_point(depth_frame, x_pix, y_pix)
        #depth = conv_get_depth(depth_frame, x_pix, y_pix)
        #print('point:', point)
        #returns ~3600-3700 for 1 meter

        return Point(point[0], point[2], point[1]) # Depth is y, y_pix is z



    def run(self):
        rospy.init_node('record_depth_cam')
        print('Running...')
        while not rospy.is_shutdown():
            # Get frame
            ret, bgr_frame, depth_frame = self.rs.get_frame_stream()

            self.frame_buffer = bgr_frame
            self.depth_buffer.append(depth_frame)

            if len(self.depth_buffer) > 10:
                self.depth_buffer.pop(0)

            #print('Record frame:', self.frame_num)

            self.frame_num += 1

            color = (0, 255, 0)

            #print('Curr pos:', self.curr_pos)

            # Draw a circle on the object if it was recently detected
            if self.frame_num < self.curr_pos_frameID + 10:
                bgr_frame = cv2.circle(bgr_frame, self.curr_pos, 5, color, -1)


            cv2.imshow('Depth', bgr_frame)
            key = cv2.waitKey(1)
            if key == 27:
                break

            # put back in the code to show frames
            

        self.rs.release()
        cv2.destroyAllWindows()

if __name__ == "__main__":
    cam = CamServer()
    cam.run()