#!/usr/bin/env python

# Payload Control System

import rospy
import smach
import smach_ros

#from marsha_core.marsha_services.move_cmds import *
#from marsha_core.marsha_services.gripper_cmds import *

from marsha_core.pcs_node import PCSstate
from marsha_core.pcs_node import PCScmd

import os
import serial
from subprocess import Popen, PIPE, STDOUT

from marsha_msgs.srv import StateComm
from marsha_msgs.srv import PayloadCmd

NUM_CONNECTION_ATTEMPTS = 3

# Used to check jetson power
#os.system("sudo chmod 777 /sys/bus/i2c/drivers/ina3221x/6-0040/iio:device0/in_voltage1_input")

def jets_connected():
    other_jet = "jet"
    this_jet = "marsha"
    p = Popen('ping ' + other_jet, stdout=PIPE, stderr = STDOUT, shell=True)

    num_attempts = 0
    num_connections = 0
    first_line = p.stdout.readline()
    while num_attempts < NUM_CONNECTION_ATTEMPTS:
        line = p.stdout.readline()
        beginning = line.split("(")[0]

        if beginning == "64 bytes from " + other_jet + " ":
            num_connections += 1
        elif beginning == "From " + this_jet + " ":
            pass
        else:
            rospy.logwarn(line)


        num_attempts += 1
    if num_connections == NUM_CONNECTION_ATTEMPTS:
        return True
    else:
        return False

def teensy_connected():
    """
    Find way to test teensy connection!
    os.system("sudo chmod -R 777 /dev/ttyTHS1")
    try:
        arduino = serial.Serial(
            port = '/dev/ttyTHS1',
            baudrate = 115200,
            bytesize = serial.EIGHTBITS,
            parity = serial.PARITY_NONE,
            stopbits = serial.STOPBITS_ONE,
            timeout = 5,
            xonxoff = False,
            rtscts = False,
            dsrdtr = False,
            writeTimeout = 2
        )
        print(arduino.write(" "))
    except Exception as e:
        print(e)
    """
    return True

def power_consumption():

    f = open("/sys/bus/i2c/drivers/ina3221x/6-0040/iio:device0/in_voltage1_input", "r")
    voltage = f.read()
    f.close()
    print(voltage)


def get_node_id(name):
    pcs_nodes = rospy.get_param("/pcs_nodes")
    return pcs_nodes.index(name)


class PCS_Node(object):
    def __init__(self, id):
        self.id = id
        self.state = -1

# ---------------------------------------------------------------- #
#                          States                                  #
# ---------------------------------------------------------------- #

class PCS_State(smach.State):
    def __init__(self, pcs_node_name=None, pcs_node_state=None, pcs_node_cmd=None, state_comm=None):
        smach.State.__init__(self, outcomes=['Success', 'Error'])

        self.read_state_comm = state_comm
        self.pcs_node_state = pcs_node_state
        self.pcs_node_cmd = pcs_node_cmd

        pcs_nodes = rospy.get_param("/pcs_nodes")
        self.node_id = pcs_nodes.index(pcs_node_name)

class PCS_Activate_State(PCS_State):
    def execute(self, userdata):
        self.pcs_node_cmd(self.node_id, PCScmd.ACTIVATE)

        while self.pcs_node_state(self.node_id) == PCSstate.NA:
            rospy.sleep(0.5)
        
        if self.pcs_node_state(self.node_id) == PCSstate.GOOD:
            return 'Success'
        else:
            return 'Error'

class PCS_Deactivate_State(PCS_State):
    def execute(self, userdata):
        self.pcs_node_cmd(self.node_id, PCScmd.DEACTIVATE)

        while self.pcs_node_state(self.node_id) == PCSstate.GOOD:
            rospy.sleep(0.5)
        
        if self.pcs_node_state(self.node_id) == PCSstate.DISABLED:
            return 'Success'
        else:
            return 'Error'



class Jetson_Comm_Check(smach.State):
    def __init__(self, check_connection):
        smach.State.__init__(self, outcomes=['Success', 'Error'])

        self.check_connection = check_connection

    def execute(self, userdata):
        if self.check_connection():
            rospy.loginfo("Jets Connected!")
            return 'Success'
        else:
            return 'Error'

class Jetson_Sync(smach.State):
    def __init__(self, sync_id, jet_comm, handshake, timeout=10, poll_period=0.1): # timeout in seconds
        smach.State.__init__(self, outcomes=['Ready', 'Timeout'])

        self.sync_id = sync_id
        self.read_jet_comm = jet_comm
        self.timeout = timeout
        self.poll_period = poll_period
        self.handshake_complete = handshake[0]
        self.reset_handshake_status = handshake[1]


    def execute(self, userdata):
        rospy.loginfo("Syncing Jets...")

        time_elapsed = 0

        # waits until other jetson is on the same state
        while self.read_jet_comm().current_state != 'Jetson_Sync_' + str(self.sync_id):
            rospy.sleep(self.poll_period)
            time_elapsed += self.poll_period
            if time_elapsed > self.timeout:
                return 'Timeout'

        # waits until other jetson asks the state
        while not self.handshake_complete():
            rospy.sleep(self.poll_period)
            time_elapsed += self.poll_period
            if time_elapsed > self.timeout:
                return 'Timeout'
        
        self.reset_handshake_status()

        return 'Ready'


class Teensy_Comm_Check(PCS_Activate_State):
    pass

class Wait_for_TE(PCS_Activate_State):
    pass

class Activate_Longeron_Cams(PCS_Activate_State):
    pass

class Deactivate_Longeron_Cams(PCS_Deactivate_State):
    pass


    



    
# ---------------------------------------------------------------- #
#                       State Machine                              #
# ---------------------------------------------------------------- #

class PCS_SM(object):
    def __init__(self):

        self.stateComm = rospy.Service('pcs_comm', StateComm, self.state_comm_callback)

        # ensures both jetsons are on the same sync state
        self.curr_sync_id = 0
        self.handshake_status = False


        self.sm = smach.StateMachine(outcomes=["Mission_Success", "Mission_Fail"])

        rospy.Service('payload_cmd', PayloadCmd, self.payload_cmd_cb)

        pcs_nodes = rospy.get_param("/pcs_nodes")

        # this list contains the state for each node
        # access a node's state with self.pcs_nodes[node_id]
        self.pcs_node_states = [-1] * len(pcs_nodes)
        self.pcs_node_cmds = [-1] * len(pcs_nodes)


        other_arm = None
        if rospy.get_namespace() == "/left/":
            other_arm = "/right/"
        else:
            other_arm = "/left/"

        self.jet_connection = jets_connected()

        # Note: This needs to be done after comm check
        rospy.loginfo('Waiting for service...')
        if self.jet_connection:
            rospy.wait_for_service(other_arm + 'pcs_comm')
            self.jet_comm = rospy.ServiceProxy(other_arm + 'pcs_comm', StateComm)

        self.mission_sm()

    def connection_status(self):
        return self.jet_connection

    def state_comm_callback(self, req):
        states = self.sm.get_active_states()
        if states[0] == 'Jetson_Sync_' + str(self.curr_sync_id):
            self.handshake_status = True

        return states[0]

    def get_handshake_status(self):
        return self.handshake_status

    def reset_handshake(self):
        self.handshake_status = False

    def payload_cmd_cb(self, msg):
        rospy.logdebug("From: " + str(msg.pcs_id) + " Msg: " + str(msg.state))

        self.pcs_node_states[msg.pcs_id] = msg.state

        return self.pcs_node_cmds[msg.pcs_id]

    def pcs_node_state(self, node_id):
        return self.pcs_node_states[node_id]

    def pcs_node_cmd(self, node_id, cmd):
        self.pcs_node_cmds[node_id] = cmd


    def mission_sm(self):
        handshake = (self.get_handshake_status, self.reset_handshake)
        with self.sm:
            smach.StateMachine.add('Jetson_Comm_Check', Jetson_Comm_Check(self.connection_status),
                                transitions={'Success': 'Jetson_Sync_0', # usually Teensy comm check
                                             'Error': 'Mission_Fail'})

            smach.StateMachine.add('Jetson_Sync_0', Jetson_Sync(0, self.jet_comm, handshake),
                                transitions={'Ready': 'Wait_for_TE',
                                             'Timeout': 'Mission_Fail'})

            smach.StateMachine.add('Teensy_Comm_Check', Teensy_Comm_Check("teensy_interface", self.pcs_node_state, self.pcs_node_cmd),
                                transitions={'Success': 'Wait_for_TE',
                                             'Error': 'Mission_Fail'})

            smach.StateMachine.add('Wait_for_TE', Wait_for_TE("te_detector", self.pcs_node_state, self.pcs_node_cmd),
                                transitions={'Success': 'Mission_Success',
                                             'Error': 'Mission_Fail'})

            smach.StateMachine.add('Activate_Longeron_Cams', Activate_Longeron_Cams("longeron_cams", self.pcs_node_state, self.pcs_node_cmd),
                                transitions={'Success': 'Deactivate_Longeron_Cams',
                                             'Error': 'Mission_Fail'})

            smach.StateMachine.add('Deactivate_Longeron_Cams', Deactivate_Longeron_Cams("longeron_cams", self.pcs_node_state, self.pcs_node_cmd),
                                transitions={'Success': 'Mission_Success',
                                             'Error': 'Mission_Fail'})

    

    def run(self):
        outcome = self.sm.execute()

if __name__ == "__main__":
    rospy.init_node("PCS")
    sm = PCS_SM()
    try:
        sm.run()
    except KeyboardInterrupt:
        pass